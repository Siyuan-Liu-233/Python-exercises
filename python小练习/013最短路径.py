# 今天继续研究和路径相关的问题，我们来看看三角形从顶端到底端的最优路径。

# 下面的三角形从顶端到底端的最优路径（路径上的数字相加最小），已经用红色数字标出了。

# 规则是：三角形从顶端开始依次往下走一层，可以选择下方相邻的2个数字中的一个，但是不能逆向，不能横向行走。

# 那么对于一个有20层的三角形，从顶端到底端的最优路径的和又是多少呢？
# 59
# 73 41
# 52 40 09
# 26 53 06 34
# 10 51 87 86 81
# 61 95 66 57 25 68
# 90 81 80 38 92 67 73
# 30 28 51 76 81 18 75 44
# 84 14 95 87 62 81 17 78 58
# 21 46 71 58 02 79 62 39 31 09
# 56 34 35 53 78 31 81 18 90 93 15
# 78 53 04 21 84 93 32 13 97 11 37 51
# 45 03 81 79 05 18 78 86 13 30 63 99 95
# 39 87 96 28 03 38 42 17 82 87 58 07 22 57
# 06 17 51 17 07 93 09 07 75 97 95 78 87 08 53
# 67 66 59 60 88 99 94 65 55 77 55 34 27 53 78 28
# 76 40 41 04 87 16 09 42 75 69 23 97 30 60 10 79 87
# 12 10 44 26 21 36 32 84 98 60 13 12 36 16 63 31 91 35
# 70 39 06 05 55 27 38 48 28 22 34 35 62 62 15 14 94 89 86
# 66 56 68 84 96 21 34 34 34 81 62 40 65 54 62 05 98 03 02 60
import copy

data = '''59
73 41
52 40 09
26 53 06 34
10 51 87 86 81
61 95 66 57 25 68
90 81 80 38 92 67 73
30 28 51 76 81 18 75 44
84 14 95 87 62 81 17 78 58
21 46 71 58 02 79 62 39 31 09
56 34 35 53 78 31 81 18 90 93 15
78 53 04 21 84 93 32 13 97 11 37 51
45 03 81 79 05 18 78 86 13 30 63 99 95
39 87 96 28 03 38 42 17 82 87 58 07 22 57
06 17 51 17 07 93 09 07 75 97 95 78 87 08 53
67 66 59 60 88 99 94 65 55 77 55 34 27 53 78 28
76 40 41 04 87 16 09 42 75 69 23 97 30 60 10 79 87
12 10 44 26 21 36 32 84 98 60 13 12 36 16 63 31 91 35
70 39 06 05 55 27 38 48 28 22 34 35 62 62 15 14 94 89 86
66 56 68 84 96 21 34 34 34 81 62 40 65 54 62 05 98 03 02 60'''
# data=data.split('\n')
# for i in range(20):
# 	data[i]=[int(s) for s in data[i].split(' ')]
# howLong=copy.deepcopy(data)
# rount=[[[] for j in range(i+1)]for i in range(20)]
# rount[0][0].append(data[0][0])
# for i in range(1,20):
# 	for j in range(0,i+1):
# 		if j == 0:
# 			howLong[i][j]+=howLong[i-1][0]
# 			rount[i][j]=copy.deepcopy(rount[i-1][j])
# 			rount[i][j].append(data[i][j])
# 		elif j==i:
# 			howLong[i][j]+=howLong[i-1][i-1]
# 			rount[i][j]=copy.deepcopy(rount[i-1][i-1])
# 			rount[i][j].append(data[i][j])
# 		else:
			
# 			if howLong[i-1][j-1]>=howLong[i-1][j]:
# 				rount[i][j]=copy.deepcopy(rount[i-1][j])
# 				howLong[i][j]+=howLong[i-1][j]
# 				rount[i][j].append(data[i][j])
# 			else:
# 				rount[i][j]=copy.deepcopy(rount[i-1][j-1])
# 				howLong[i][j]+=howLong[i-1][j-1]
# 				rount[i][j].append(data[i][j])
# rount[19]=sorted(rount[19],key=sum)
# print(min(howLong[19]))
# print(rount[19][0])

#############递归##############
import copy

data = '''59
73 41
52 40 09
26 53 06 34
10 51 87 86 81
61 95 66 57 25 68
90 81 80 38 92 67 73
30 28 51 76 81 18 75 44
84 14 95 87 62 81 17 78 58
21 46 71 58 02 79 62 39 31 09
56 34 35 53 78 31 81 18 90 93 15
78 53 04 21 84 93 32 13 97 11 37 51
45 03 81 79 05 18 78 86 13 30 63 99 95
39 87 96 28 03 38 42 17 82 87 58 07 22 57
06 17 51 17 07 93 09 07 75 97 95 78 87 08 53
67 66 59 60 88 99 94 65 55 77 55 34 27 53 78 28
76 40 41 04 87 16 09 42 75 69 23 97 30 60 10 79 87
12 10 44 26 21 36 32 84 98 60 13 12 36 16 63 31 91 35
70 39 06 05 55 27 38 48 28 22 34 35 62 62 15 14 94 89 86
66 56 68 84 96 21 34 34 34 81 62 40 65 54 62 05 98 03 02 60'''
data=data.split('\n')
for i in range(20):
	data[i]=[int(s) for s in data[i].split(' ')]
howLong=copy.deepcopy(data)
def getlong(i,j,data=data,howLong=howLong):
	if i==0 and j==0:
		return 59
	elif howLong[i][j]!=data[i][j]:
		return howLong[i][j]
	if j==0:
		howLong[i][j]+=getlong(i-1,j)
	elif j==i:
		howLong[i][j]+=getlong(i-1,i-1)
	else:
		howLong[i][j]+=min(getlong(i-1,j-1),getlong(i-1,j))
	return howLong[i][j]
for i in range(20):
	getlong(19,i)
print(min(howLong[19]))